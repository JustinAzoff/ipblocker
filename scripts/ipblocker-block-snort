#!/usr/bin/env python 
from snort import snortdb
from ipblocker import block_ip, get_blocked_ip, is_reblockable, is_fishy, get_block_pending
from ipblocker import logger
import os
from ipblocker.util import groupby, subnet, wakeup_backend
from operator import itemgetter

import datetime

#TODO: put in config file
sigs = [
    'ET SCAN LibSSH Based SSH Connection',
    'ET SCAN Potential SSH Scan',
    'VNC Scan 5900-5920',
    'ET EXPLOIT RealVNC Authentication Bypass Attempt',
    'ET SCAN MYSQL 4.1 brute force root login attempt', 
    'ET SCAN Behavioral Unusually fast Terminal Server Traffic, Potential Scan or Infection',
    'ET SCAN Tomcat Auth Brute Force attempt',
]
MINIMUM = 32
SUBNET_MINIMUM = 3

BLOCK_TIME = 60*60*24

def num_subnets(alerts):
    by_dst = groupby(alerts, lambda a: subnet(a['ip_dst']))
    return len(list(by_dst))

def do_sigs():
    snort=snortdb.sdb()
    snort.setwhere(range='hour',span=1)
    snort.limit=None

    alerts = []
    for sig in sigs:
        for a in snort.find(sig=sig):
            alerts.append(a)
    by_src = groupby(alerts, itemgetter("ip_src"))
        
    for ip, alerts in by_src:
        alerts = list(alerts)
        if is_reblockable(str(ip)) or is_fishy(str(ip)) or (len(alerts) >= MINIMUM and num_subnets(alerts) >= SUBNET_MINIMUM):
            yield ip, alerts

def make_txt(alerts):
    txt = "%d alerts (%d subnets)\n" % (len(alerts), num_subnets(alerts))
    for a in alerts[:5]:
        txt += "%(timestamp)s %(ip_src)s:%(sport)s -> %(ip_dst)s:%(dport)s %(sig)s\n" % a
    if len(alerts) > 5:
        txt += "...\n"
        for a in alerts[-5:]:
            txt += "%(timestamp)s %(ip_src)s:%(sport)s -> %(ip_dst)s:%(dport)s %(sig)s\n" % a
    return txt

def block(ip, alerts, force_block=False):
    ip = str(ip)
    txt = make_txt(alerts)


    block_record = get_blocked_ip(ip)

    if not block_record and not force_block:
        print txt
        confirm = raw_input("Block %s ? [type 'yes'] " % ip)
        if confirm != 'yes':
            return False

    block_ip(ip=ip, who='snort', comment=txt, duration=BLOCK_TIME, extend_only=True)

    if not block_record:
        logger.info("%s blocked: %s" % (ip, txt))
    else:
        logger.debug("%s re-blocked" % ip)
    return True


def main(force_block=False):
    for ip, alerts in do_sigs():
        block(ip, alerts, force_block)
    if get_block_pending():
        wakeup_backend()

if __name__ == "__main__":
    from optparse import OptionParser
    parser = OptionParser()
    parser.add_option("-f", "--force",  dest="force", action="store_true", help="block without confirmation",default=False)
    (options, args) = parser.parse_args()
    main(options.force)
