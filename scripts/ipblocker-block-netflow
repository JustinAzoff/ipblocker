#!/usr/bin/env python 
import pynfdump
from ipblocker import block_ip, get_blocked_ip, is_reblockable, is_fishy
from ipblocker import logger
from ipblocker import is_country_ok
from ipblocker import util, config

from operator import itemgetter
import datetime
import os

TOTAL_MINIMUM = 128
BAD_COUNTRY_SUBNET_MINIMUM = 1
OK_COUNTRY_SUBNET_MINIMUM = 3

country_ok_min_mapping = {
    True: OK_COUNTRY_SUBNET_MINIMUM,
    False: BAD_COUNTRY_SUBNET_MINIMUM,
}

BLOCK_TIME = 60*60*24*7

def num_subnets(flows):
    by_dst = util.groupby(flows, lambda a: util.subnet(a['dstip']))
    return len(list(by_dst))

def should_block(ip):
    if is_reblockable(ip):
        return True
    if is_fishy(ip):
        return True
    return False

def do_ports():
    filt = config.get("netflow", "filter")
    netflow_dir = config.get("netflow", "dir")
    sources     = config.get("netflow", "sources").split(",")
    remote_host = config.get("netflow", "remote_host")

    d=pynfdump.Dumper(netflow_dir, sources=sources, remote_host=remote_host)
    d.set_where(start=str(datetime.date.today()))

    flows = d.search(filt, aggregate='srcip,dstip,dstport')
    by_src = util.groupby(flows, itemgetter("srcip"))
    countries = util.lookup_countries(str(ip) for ip,flows in by_src if len(flows) >= TOTAL_MINIMUM)

    for ip, flows in by_src:
        rec = countries.get(ip)
        ip = str(ip)
        if should_block(ip):
            yield ip, flows, rec
        else:
            if len(flows) < TOTAL_MINIMUM:
                continue
            country_ok = is_country_ok(rec and rec.cc or None)
            minimum = country_ok_min_mapping[country_ok]
            if num_subnets(flows) >= minimum:
                yield ip, flows, rec

def make_txt(flows, rec):
    txt = "%d flows (%d subnets) from %s\n" % (len(flows), num_subnets(flows), rec and rec.cc)
    for a in flows[:5]:
        txt += "%(last)s %(srcip)s:%(srcport)s -> %(dstip)s:%(dstport)s\n" % a
    txt += "...\n"
    for a in flows[-5:]:
        txt += "%(last)s %(srcip)s:%(srcport)s -> %(dstip)s:%(dstport)s\n" % a
    return txt

def block(ip, flows, rec, force_block=False):
    ip = str(ip)
    txt = make_txt(flows, rec)

    block_record = get_blocked_ip(ip)

    if not block_record and not force_block:
        print txt
        confirm = raw_input("Block %s ? [type 'yes'] " % ip)
        if confirm != 'yes':
            return False

    block_ip(ip=ip, who='netflow', comment=txt, duration=BLOCK_TIME, extend_only=True)

    if not block_record:
        logger.info("%s blocked: %s" % (ip, txt))
    else:
        logger.debug("%s re-blocked" % ip)
    return True


def main(force_block=False):
    for ip, flows, rec in do_ports():
        block(ip, flows, rec, force_block)

if __name__ == "__main__":
    from optparse import OptionParser
    parser = OptionParser()
    parser.add_option("-f", "--force",  dest="force", action="store_true", help="block without confirmation",default=False)
    (options, args) = parser.parse_args()
    main(options.force)
