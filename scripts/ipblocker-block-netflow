#!/usr/bin/env python 
import pynfdump
from ipblocker import block_ip, get_blocked_ip, is_reblockable, is_fishy
from ipblocker import logger
from ipblocker import is_country_ok
from ipblocker import util

from operator import itemgetter
import datetime
import os

#TODO: put in config file
PORTS = "22 25 3389 5900 5901"
FILT="dst port in [%s] and dst net 169.226.0.0/16 and flags S and not flags A" % PORTS

MINIMUM = 128
BAD_COUNTRY_SUBNET_MINIMUM = 1
OK_COUNTRY_SUBNET_MINIMUM = 3

country_ok_min_mapping = {
    True: OK_COUNTRY_SUBNET_MINIMUM,
    False: BAD_COUNTRY_SUBNET_MINIMUM,
}

BLOCK_TIME = 60*60*24*7

def num_subnets(flows):
    by_dst = util.groupby(flows, lambda a: util.subnet(a['dst']))
    return len(list(by_dst))

def should_block(ip):
    ip = str(ip)
    if is_reblockable(ip):
        return True
    if is_fishy(ip):
        return True
    return False

def do_ports():
    d=pynfdump.Dumper('/data/nfsen/profiles/',sources=['podium'],remote_host='root@glenn')
    d.set_where(start=str(datetime.date.today()))

    flows = d.search(FILT, aggregate='srcip,dstip,dstport')
    by_src = util.groupby(flows, itemgetter("src"))
    countries = util.lookup_countries(str(ip) for ip,flows in by_src if len(flows) >= MINIMUM)

    for ip, flows in by_src:
        if len(flows) < MINIMUM:
            continue
        ip = str(ip)
        country_ok = is_country_ok(countries.get(ip).cc)
        minimum = country_ok_min_mapping[country_ok]
        if should_block(ip) or num_subnets(flows) >= minimum:
            yield ip, flows

def make_txt(flows):
    txt = "%d flows (%d subnets)\n" % (len(flows), num_subnets(flows))
    for a in flows[:5]:
        txt += "%(last)s %(src)s:%(srcport)s -> %(dst)s:%(dstport)s\n" % a
    txt += "...\n"
    for a in flows[-5:]:
        txt += "%(last)s %(src)s:%(srcport)s -> %(dst)s:%(dstport)s\n" % a
    return txt

def block(ip, flows, force_block=False):
    ip = str(ip)
    txt = make_txt(flows)


    block_record = get_blocked_ip(ip)

    if not block_record and not force_block:
        print txt
        confirm = raw_input("Block %s ? [type 'yes'] " % ip)
        if confirm != 'yes':
            return False

    block_ip(ip=ip, who='netflow', comment=txt, duration=BLOCK_TIME, extend_only=True)

    if not block_record:
        logger.info("%s blocked: %s" % (ip, txt))
    else:
        logger.debug("%s re-blocked" % ip)
    return True


def main(force_block=False):
    for ip, flows in do_ports():
        block(ip, flows, force_block)

if __name__ == "__main__":
    from optparse import OptionParser
    parser = OptionParser()
    parser.add_option("-f", "--force",  dest="force", action="store_true", help="block without confirmation",default=False)
    (options, args) = parser.parse_args()
    main(options.force)
