#!/usr/bin/env python 
from snort import snortdb
from ipblocker import block_ip, get_blocked_ip, is_reblockable, is_fishy, get_block_pending, disconnect
from ipblocker import logger
from ipblocker.config import config
import os
from ipblocker.util import groupby, subnet, wakeup_backend
from operator import itemgetter

import datetime


sigs            = config.get("snort", "sigs").strip().splitlines()
MINIMUM         = int(config.get("snort", "minimum"))
SUBNET_MINIMUM  = int(config.get("snort", "subnet_minimum"))
BLOCK_TIME      = config.get("snort", "block_time")

def num_subnets(alerts):
    by_dst = groupby(alerts, lambda a: subnet(a['ip_dst']))
    return len(list(by_dst))

def do_sigs():
    snort=snortdb.sdb()
    snort.setwhere(range='hour',span=1)
    snort.limit=None

    alerts = []
    for sig in sigs:
        for a in snort.find(sig=sig):
            alerts.append(a)
    by_src = groupby(alerts, itemgetter("ip_src"))
        
    for ip, alerts in by_src:
        alerts = list(alerts)
        if is_reblockable(str(ip)) or is_fishy(str(ip)) or (len(alerts) >= MINIMUM and num_subnets(alerts) >= SUBNET_MINIMUM):
            yield ip, alerts

def make_txt(alerts):
    txt = "%d alerts (%d subnets)\n" % (len(alerts), num_subnets(alerts))
    for a in alerts[:5]:
        txt += "%(timestamp)s %(ip_src)s:%(sport)s -> %(ip_dst)s:%(dport)s %(sig)s\n" % a
    if len(alerts) > 5:
        txt += "...\n"
        for a in alerts[-5:]:
            txt += "%(timestamp)s %(ip_src)s:%(sport)s -> %(ip_dst)s:%(dport)s %(sig)s\n" % a
    return txt

def block(ip, alerts, force_block=False):
    ip = str(ip)
    txt = make_txt(alerts)


    block_record = get_blocked_ip(ip)

    if not block_record and not force_block:
        print txt
        confirm = raw_input("Block %s ? [type 'yes'] " % ip)
        if confirm != 'yes':
            return False

    block_ip(ip=ip, who='snort', comment=txt, duration=BLOCK_TIME, extend_only=True)

    if not block_record:
        logger.info("%s blocked: %s" % (ip, txt))
    else:
        logger.debug("%s re-blocked" % ip)
    return True


def main(force_block=False):
    for ip, alerts in do_sigs():
        try :
            block(ip, alerts, force_block)
        except Exception, e:
            logger.exception("Error blocking %s" % ip)
    if get_block_pending():
        wakeup_backend()
    disconnect()

if __name__ == "__main__":
    from optparse import OptionParser
    parser = OptionParser()
    parser.add_option("-f", "--force",  dest="force", action="store_true", help="block without confirmation",default=False)
    (options, args) = parser.parse_args()
    main(options.force)
