#!/usr/bin/env python 
from snort import snortdb
from ipblocker import block_ip, get_blocked_ip
from ipblocker import logger
import os
from itertools import groupby
from operator import itemgetter

import datetime

sigs = [
    'ET SCAN LibSSH Based SSH Connection',
    'ET SCAN Potential SSH Scan',
    'ET SCAN Potential VNC Scan 5900-5920',
    'ET SCAN MYSQL 4.1 brute force root login attempt', 
]
MINIMUM = 32
SUBNET_MINIMUM = 3

BLOCK_TIME = 60*60*24

def subnet(ip):
    """1.2.3.4 -> 3"""
    return (ip.int()/256)&255

def num_subnets(alerts):
    by_dst = groupby(alerts, lambda a: subnet(a['ip_dst']))
    return len(list(by_dst))

def do_sigs():
    snort=snortdb.sdb()
    snort.setwhere(range='hour',span=1)
    alerts = []
    for sig in sigs:
        for a in snort.find(sig=sig):
            alerts.append(a)
    by_src = groupby(alerts, itemgetter("ip_src"))
        
    for ip, alerts in by_src:
        alerts = list(alerts)
        if len(alerts) >= MINIMUM and num_subnets(alerts) >= SUBNET_MINIMUM:
            yield ip, alerts

def make_txt(alerts):
    txt = "%d alerts (%d subnets)\n" % (len(alerts), num_subnets(alerts))
    for a in alerts[:5]:
        txt += "%(timestamp)s %(ip_src)s:%(sport)s -> %(ip_dst)s:%(dport)s %(sig)s\n" % a
    txt += "...\n"
    for a in alerts[-5:]:
        txt += "%(timestamp)s %(ip_src)s:%(sport)s -> %(ip_dst)s:%(dport)s %(sig)s\n" % a
    return txt

def block(ip, alerts):
    ip = str(ip)
    txt = make_txt(alerts)


    block_record = get_blocked_ip(ip)

    #if not block_record:
    #    confirm = raw_input("Block %s ? [type 'yes'] " % ip)
    #    if confirm != 'yes':
    #        return False

    block_ip(ip=ip, who='snort', comment=txt, duration=BLOCK_TIME, extend_only=True)

    if not block_record:
        logger.debug("%s re-blocked" % ip)
    else:
        logger.info("%s blocked: %s" % (ip, txt))
    return True


def main():
    for ip, alerts in do_sigs():
        block(ip, alerts)
if __name__ == "__main__":
    main()

